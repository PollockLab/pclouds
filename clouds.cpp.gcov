        -:    0:Source:clouds.cpp
        -:    0:Graph:clouds.gcno
        -:    0:Data:clouds.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    0:Source is newer than graph
        -:    1:/**
        -:    2: * STP: This is clearly a cpp file. It used to be named *.c.
        -:    3: *
        -:    4: */
        -:    5:
        -:    6:#include <cstdlib>
        -:    7:#include <stdio.h>
        -:    8:#include <time.h>
        -:    9:#include <algorithm>
        -:   10:#include <ext/algorithm>
        -:   11:#include <math.h>
        -:   12:#include <iostream>
        -:   13:
        -:   14:#include <cstring>
        -:   15:#include "macrodefine.h"
        -:   16:#include "readfile.h"
        -:   17:#include "stringhandle.h"
        -:   18:
        -:   19:#include <cstdlib>
        -:   20:
        -:   21:#include <fstream> // for printing edges between core nodes in expansion network
        -:   22:using std::swap;
        -:   23:using std::cout;
        -:   24:using std::cerr;
        -:   25:using std::endl;
        -:   26:using std::sort;
        -:   27:
        -:   28:
        -:   29:bool keep_SSRs = false;
        -:   30:bool print_clouds_in_regions = false;
        -:   31:bool print_legacy_regions = false;
        -:   32:bool expand_recursively = false;
        -:   33:
        -:   34:#include <deque> // For clouds in regions
        -:   35:
    79500:   36:static int sbsearch2(int n, const cloud_type2 *argv, const unsigned long& key) {
        -:   37:	int m;
    79500:   38:	int site = 0;
        -:   39:
  1440338:   40:	while (n >= 1) {
  1301890:   41:		m = n / 2;
  1301890:   42:		if (argv[site + m].index == key)
    20552:   43:			return (site + m);
  1281338:   44:		else if (argv[site + m].index > key)
   662132:   45:			n = m;
        -:   46:		else {
   619206:   47:			site = site + m + 1;
   619206:   48:			n = n - m - 1;
        -:   49:		}
        -:   50:	}
        -:   51:
    58948:   52:	return (-1);
        -:   53:}
        -:   54:
        -:   55://STP: Is this a binary search algorithm?
 18515846:   56:static int sbsearch3(int nOligos, const cloud_type3 *oligos,
        -:   57:		const unsigned long& key) {
        -:   58:	int m;
 18515846:   59:	int site = 0;
        -:   60:
260448570:   61:	while (nOligos >= 1) {
223738578:   62:		m = nOligos / 2;
223738578:   63:		if (oligos[site + m].number_pattern == key)
   321700:   64:			return (site + m);
223416878:   65:		else if (oligos[site + m].number_pattern > key)
114491412:   66:			nOligos = m;
        -:   67:		else {
108925466:   68:			site = site + m + 1;
108925466:   69:			nOligos = nOligos - m - 1;
        -:   70:		}
        -:   71:	}
        -:   72:
 18194146:   73:	return (-1);
        -:   74:}
        -:   75:
   210164:   76:static bool highnumber3(cloud_type3 a, cloud_type3 b) {
   210164:   77:	if (a.number > b.number)
    58624:   78:		return (1);
        -:   79:	else
   151540:   80:		return (0);
        -:   81:}
        -:   82:
  2943302:   83:static bool lowsequence2(cloud_type2 a, cloud_type2 b) {
  2943302:   84:	if (a.index < b.index)
  2672568:   85:		return (1);
        -:   86:	else
   270734:   87:		return (0);
        -:   88:}
        -:   89:
   134708:   90:static bool lowsequence3(cloud_type3 a, cloud_type3 b) {
   134708:   91:	if (a.number_pattern < b.number_pattern)
    85912:   92:		return (1);
        -:   93:	else
    48796:   94:		return (0);
        -:   95:}
        -:   96:
   602946:   97:static int getnumber(char* pchLine) {
   602946:   98:	int i = 0;
   602946:   99:	int temp = 0;
        -:  100:
  7235352:  101:	while (pchLine[i] != ' ')
  6029460:  102:		i++;
        -:  103:
   602946:  104:	i++;
        -:  105:
  1812222:  106:	while ((pchLine[i] >= ZERO) && (pchLine[i] <= NINE)) {
   606330:  107:		temp = temp * 10 + pchLine[i] - ZERO;
   606330:  108:		i++;
        -:  109:	}
        -:  110:
   602946:  111:	return (temp);
        -:  112:}
        -:  113:
     8606:  114:static void getcloudandnumber(char* pchLine, int& cloud, int& number) {
     8606:  115:	int i = 0;
        -:  116:
     8606:  117:	cloud = 0;
        -:  118:
   103272:  119:	while (pchLine[i] != ' ')
    86060:  120:		i++;
        -:  121:
     8606:  122:	i++;
        -:  123:
    26408:  124:	while ((pchLine[i] >= ZERO) && (pchLine[i] <= NINE)) {
     9196:  125:		cloud = cloud * 10 + pchLine[i] - ZERO;
     9196:  126:		i++;
        -:  127:	}
        -:  128:
    17212:  129:	while (pchLine[i] != ' ')
    #####:  130:		i++;
        -:  131:
     8606:  132:	i++;
        -:  133:
     8606:  134:	number = 0;
        -:  135:
    26946:  136:	while ((pchLine[i] >= ZERO) && (pchLine[i] <= NINE)) {
     9734:  137:		number = number * 10 + pchLine[i] - ZERO;
     9734:  138:		i++;
        -:  139:	}
     8606:  140:}
        -:  141:
    #####:  142:static void swapcloud(cloud_type3& a, cloud_type3& b) {
    #####:  143:	swap(a.number_pattern, b.number_pattern);
    #####:  144:	swap(a.number, b.number);
    #####:  145:	swap(a.cloud, b.cloud);
    #####:  146:	swap(a.extension, b.extension);
    #####:  147:}
        -:  148:
    #####:  149:static void q_sort(cloud_type3* repeats, int left, int right) {
        -:  150:	int pivot, l, r;
    #####:  151:	l = left;
    #####:  152:	r = right;
    #####:  153:	pivot = repeats[(left + right) / 2].number;
    #####:  154:	while (l < r) {
    #####:  155:		while (repeats[l].number > pivot)
    #####:  156:			++l;
        -:  157:
    #####:  158:		while (repeats[r].number < pivot)
    #####:  159:			--r;
        -:  160:
    #####:  161:		if (l >= r)
    #####:  162:			break;
        -:  163:
    #####:  164:		swapcloud(repeats[l], repeats[r]);
    #####:  165:		++l;
    #####:  166:		--r;
        -:  167:	}
        -:  168:
    #####:  169:	if (l == r)
    #####:  170:		l++;
        -:  171:
    #####:  172:	if (left < r)
    #####:  173:		q_sort(repeats, left, l - 1);
    #####:  174:	if (l < right)
    #####:  175:		q_sort(repeats, r + 1, right);
    #####:  176:}
        -:  177:
        -:  178:// transform the pattern sequence to the index of the array
        -:  179:// coding method: A=00, C=01, G= 10, T=11,
 18788834:  180:static void patterntoindex(const char *pchPattern, unsigned long& index,
        -:  181:		const int& patternsize) {
        -:  182:	int i;
 18788834:  183:	index = 0;
206677174:  184:	for (i = 0; i < patternsize; i++) {
187888340:  185:		index *= 4;
187888340:  186:		if ((*(pchPattern + i) == 'a') || (*(pchPattern + i) == 'A'))
 49278962:  187:			index += 0;
138609378:  188:		else if ((*(pchPattern + i) == 'c') || (*(pchPattern + i) == 'C'))
 44670070:  189:			index += 1;
 93939308:  190:		else if ((*(pchPattern + i) == 'g') || (*(pchPattern + i) == 'G'))
 44664184:  191:			index += 2;
 49275124:  192:		else if ((*(pchPattern + i) == 't') || (*(pchPattern + i) == 'T'))
 49275124:  193:			index += 3;
        -:  194:	}
 18788834:  195:}
        -:  196:
    43694:  197:static void number_pattern_to_kmer_sequence(char *pchPattern,
        -:  198:		const unsigned long& index, const int& patternsize) {
        -:  199:	int i;
        -:  200:	unsigned long value;
    43694:  201:	unsigned long temp = index;
        -:  202:
   480634:  203:	for (i = patternsize - 1; i >= 0; i--) {
   436940:  204:		value = temp % 4;
   436940:  205:		if (value == 0)
   121266:  206:			*(pchPattern + i) = 'A';
   315674:  207:		else if (value == 1)
    99128:  208:			*(pchPattern + i) = 'C';
   216546:  209:		else if (value == 2)
    96364:  210:			*(pchPattern + i) = 'G';
   120182:  211:		else if (value == 3)
   120182:  212:			*(pchPattern + i) = 'T';
   436940:  213:		temp = temp / 4;
        -:  214:	}
        -:  215:
        -:  216:	// This needs to be null terminated
    43694:  217:	*(pchPattern + patternsize) = '\0';
    43694:  218:}
        -:  219:
        4:  220:ofstream testmers("testmers");
        -:  221:
        -:  222:// Generates all the possible kmers (and their reverse complements) that are
        -:  223:// one substitution away from pchCore
     3630:  224:static void getonesubstitutions(const char* core_kmer,
        -:  225:		unsigned long* array_of_testmer_number_patterns,
        -:  226:		int& number_of_testmers) {
     3630:  227:	char alphabet[5] = "ACGT";
        -:  228:
     3630:  229:	int size = strlen(core_kmer);
        -:  230:
     3630:  231:	char* testmer = new char[size + 1];
        -:  232:
    39930:  233:	for (int i = 0; i < size; i++) {
   181500:  234:		for (int k = 0; k < 4; k++) {
   145200:  235:			if (alphabet[k] != core_kmer[i]) {
   108900:  236:				strcpy(testmer, core_kmer);
   108900:  237:				testmer[i] = alphabet[k];
        -:  238:
        -:  239:				//STP: Added for reverse prototype
        -:  240://				testmers << testmer << endl;
        -:  241:
        -:  242:				patterntoindex(testmer,
   108900:  243:						array_of_testmer_number_patterns[number_of_testmers],
   217800:  244:						size);
   108900:  245:				number_of_testmers++;
        -:  246:			}
        -:  247:		}
        -:  248:	}
        -:  249:
     3630:  250:	char* reverse_core_kmer = new char[size + 1];
        -:  251:
     3630:  252:	getreversecomplement(core_kmer, reverse_core_kmer);
        -:  253:
     3630:  254:	if (strcmp(reverse_core_kmer, core_kmer) != 0) {
    39842:  255:		for (int i = 0; i < strlen(reverse_core_kmer); i++) {
   181100:  256:			for (int k = 0; k < 4; k++) {
   144880:  257:				if (alphabet[k] != reverse_core_kmer[i]) {
   108660:  258:					strcpy(testmer, reverse_core_kmer);
   108660:  259:					testmer[i] = alphabet[k];
        -:  260:
        -:  261:					//STP: Added for reverse prototype
        -:  262://					testmers << testmer << endl;
        -:  263:
        -:  264:					patterntoindex(testmer,
   108660:  265:							array_of_testmer_number_patterns[number_of_testmers],
   217320:  266:							size);
   108660:  267:					number_of_testmers++;
        -:  268:				}
        -:  269:			}
        -:  270:		}
        -:  271:	}
        -:  272:
     3630:  273:	delete[] (reverse_core_kmer);
     3630:  274:	delete[] (testmer);
        -:  275:	/*free(reverse_core_kmer);
        -:  276:	 free(testmer);*/
     3630:  277:}
        -:  278:
     2534:  279:static void gettwosubstitutions(const char* core_kmer,
        -:  280:		unsigned long* array_of_testmer_number_patterns,
        -:  281:		int& number_of_testmers) {
     2534:  282:	char alphabet[5] = "ACGT";
        -:  283:
     2534:  284:	int size = strlen(core_kmer);
        -:  285:
     2534:  286:	char* testmer = (char*) malloc(sizeof(char) * (size + 1));
        -:  287:
    25340:  288:	for (int i = 0; i < size - 1; i++) {
   136836:  289:		for (int j = i + 1; j < size; j++) {
   570150:  290:			for (int k = 0; k < 4; k++) {
  2280600:  291:				for (int l = 0; l < 4; l++) {
  3192840:  292:					if ((alphabet[k] != core_kmer[i])
  1368360:  293:							&& (alphabet[l] != core_kmer[j])) {
  1026270:  294:						strcpy(testmer, core_kmer);
  1026270:  295:						testmer[i] = alphabet[k];
  1026270:  296:						testmer[j] = alphabet[l];
        -:  297:
        -:  298:						//STP: Added for reverse prototype
        -:  299://						testmers << testmer << endl;
        -:  300:
        -:  301:						patterntoindex(testmer,
  1026270:  302:								array_of_testmer_number_patterns[number_of_testmers],
  2052540:  303:								size);
  1026270:  304:						number_of_testmers++;
        -:  305:					}
        -:  306:				}
        -:  307:			}
        -:  308:		}
        -:  309:	}
        -:  310:
     2534:  311:	char* reverse_core_kmer = (char*) malloc(sizeof(char) * (size + 1));
        -:  312:
     2534:  313:	getreversecomplement(core_kmer, reverse_core_kmer);
        -:  314:
    25340:  315:	for (int i = 0; i < strlen(reverse_core_kmer) - 1; i++) {
   136836:  316:		for (int j = i + 1; j < strlen(reverse_core_kmer); j++) {
   570150:  317:			for (int k = 0; k < 4; k++) {
  2280600:  318:				for (int l = 0; l < 4; l++) {
  3192840:  319:					if ((alphabet[k] != reverse_core_kmer[i])
  1368360:  320:							&& (alphabet[l] != reverse_core_kmer[j])) {
  1026270:  321:						strcpy(testmer, reverse_core_kmer);
  1026270:  322:						testmer[i] = alphabet[k];
  1026270:  323:						testmer[j] = alphabet[l];
        -:  324:
        -:  325:						//STP: Added for reverse prototype
        -:  326://						testmers << testmer << endl;
        -:  327:
        -:  328:						patterntoindex(testmer,
  1026270:  329:								array_of_testmer_number_patterns[number_of_testmers],
  2052540:  330:								size);
  1026270:  331:						number_of_testmers++;
        -:  332:					}
        -:  333:				}
        -:  334:			}
        -:  335:		}
        -:  336:	}
        -:  337:
     2534:  338:	free(reverse_core_kmer);
     2534:  339:	free(testmer);
     2534:  340:}
        -:  341:
     2518:  342:static void getthreesubstitutions(char* core_kmer,
        -:  343:		unsigned long* array_of_testmer_number_patterns,
        -:  344:		int& number_of_testmers) {
     2518:  345:	char alphabet[5] = "ACGT";
        -:  346:
     2518:  347:	int size = strlen(core_kmer);
        -:  348:
     2518:  349:	char* testmer = (char*) malloc(sizeof(char) * (size + 1));
        -:  350:
    22662:  351:	for (int i = 0; i < size - 2; i++) {
   110792:  352:		for (int j = i + 1; j < size - 1; j++) {
   392808:  353:			for (int m = j + 1; m < size; m++) {
  1510800:  354:				for (int k = 0; k < 4; k++) {
  6043200:  355:					for (int l = 0; l < 4; l++) {
 24172800:  356:						for (int n = 0; n < 4; n++) {
 44719680:  357:							if ((alphabet[k] != core_kmer[i])
 14503680:  358:									&& (alphabet[l] != core_kmer[j])
 10877760:  359:									&& ((alphabet[n] != core_kmer[m]))) {
  8158320:  360:								strcpy(testmer, core_kmer);
  8158320:  361:								testmer[i] = alphabet[k];
  8158320:  362:								testmer[j] = alphabet[l];
  8158320:  363:								testmer[m] = alphabet[n];
        -:  364:
        -:  365:								//STP: Added for reverse prototype
        -:  366://								testmers << testmer << endl;
        -:  367:
        -:  368:								patterntoindex(testmer,
  8158320:  369:										array_of_testmer_number_patterns[number_of_testmers],
 16316640:  370:										size);
  8158320:  371:								number_of_testmers++;
        -:  372:							}
        -:  373:						}
        -:  374:					}
        -:  375:				}
        -:  376:			}
        -:  377:		}
        -:  378:	}
        -:  379:
     2518:  380:	char* reverse_core_kmer = (char*) malloc(sizeof(char) * (size + 1));
        -:  381:
     2518:  382:	getreversecomplement(core_kmer, reverse_core_kmer);
        -:  383:
    22662:  384:	for (int i = 0; i < size - 2; i++) {
   110792:  385:		for (int j = i + 1; j < strlen(reverse_core_kmer) - 1; j++) {
   392808:  386:			for (int m = j + 1; m < strlen(reverse_core_kmer); m++) {
  1510800:  387:				for (int k = 0; k < 4; k++) {
  6043200:  388:					for (int l = 0; l < 4; l++) {
 24172800:  389:						for (int n = 0; n < 4; n++) {
 44719680:  390:							if ((alphabet[k] != reverse_core_kmer[i])
 14503680:  391:									&& (alphabet[l] != reverse_core_kmer[j])
 10877760:  392:									&& ((alphabet[n] != reverse_core_kmer[m]))) {
  8158320:  393:								strcpy(testmer, reverse_core_kmer);
  8158320:  394:								testmer[i] = alphabet[k];
  8158320:  395:								testmer[j] = alphabet[l];
  8158320:  396:								testmer[m] = alphabet[n];
        -:  397:
        -:  398:								//STP: Added for reverse prototype
        -:  399://								testmers << testmer << endl;
        -:  400:
        -:  401:								patterntoindex(testmer,
  8158320:  402:										array_of_testmer_number_patterns[number_of_testmers],
 16316640:  403:										size);
  8158320:  404:								number_of_testmers++;
        -:  405:							}
        -:  406:						}
        -:  407:					}
        -:  408:				}
        -:  409:			}
        -:  410:		}
        -:  411:	}
        -:  412:
     2518:  413:	free(reverse_core_kmer);
     2518:  414:	free(testmer);
     2518:  415:}
        -:  416:
        -:  417:// specific to use 16mers, use some different kind of coding method for each 16mer
    #####:  418:static void buildbitmatrix(bit_matrix& PatternMatrix, int* matrixsize,
        -:  419:		const int& patternsize) {
    #####:  420:	cout << "Building bit matrix" << endl;
    #####:  421:	exit(0);
        -:  422:	unsigned long index;
        -:  423:
        -:  424:	char* pchPattern = (char*) malloc(sizeof(char) * (patternsize / 2 + 1));
        -:  425:
        -:  426:	char* pchReverse = (char*) malloc(sizeof(char) * (patternsize / 2 + 1));
        -:  427:
        -:  428:	// each line correspond to each pattern with index of the last 8 chars.
        -:  429:	for (int i = 0; i < pow(4, patternsize / 2); i++) {
        -:  430:		// index equal to i, get the last 8 characters of the pattern from index
        -:  431:		index = i;
        -:  432:
        -:  433:		number_pattern_to_kmer_sequence(pchPattern, index, patternsize / 2);
        -:  434:
        -:  435:		// get the reverse complement of the last 8 characters, then get the index of the reverse complement LR
        -:  436:		//the size of the vector[i] is LR+1;
        -:  437:
        -:  438:		getreversecomplement(pchPattern, pchReverse);
        -:  439:
        -:  440:		patterntoindex(pchReverse, index, patternsize / 2);
        -:  441:
        -:  442:		PatternMatrix[i].reserve(index + 1);
        -:  443:
        -:  444:		matrixsize[i] = index + 1;
        -:  445:	}
        -:  446:
        -:  447:	free(pchPattern);
        -:  448:	free(pchReverse);
        -:  449:
        -:  450:}
        -:  451:
        -:  452:// specific to use 16mers, use some different kind of coding method for each 16mer
    #####:  453:static void getpatternmatrixindex(char* pchPattern, unsigned long& i,
        -:  454:		unsigned long& j) {
    #####:  455:	int size = strlen(pchPattern);
        -:  456:
    #####:  457:	char* pchTemp = (char*) malloc(sizeof(char) * (size / 2 + 1));
        -:  458:
        -:  459:	// get the index of last 8 chars;
    #####:  460:	strright(size / 2, pchPattern, pchTemp);
        -:  461:
    #####:  462:	patterntoindex(pchTemp, i, size / 2);
        -:  463:
        -:  464:	// get the index of the first 8 chars;
    #####:  465:	strleft(size / 2, pchPattern, pchTemp);
        -:  466:
    #####:  467:	patterntoindex(pchTemp, j, size / 2);
        -:  468:
    #####:  469:	free(pchTemp);
    #####:  470:}
        -:  471:
    #####:  472:static bool isrepeatregion(vector<int>& occurrence, const int& percent) {
    #####:  473:	vector<int>::iterator pOccurrence;
        -:  474:
    #####:  475:	int count = 0;
        -:  476:
    #####:  477:	for (pOccurrence = occurrence.begin(); pOccurrence < occurrence.end();
        -:  478:			pOccurrence++) {
    #####:  479:		if (*(pOccurrence) > 0)
    #####:  480:			count++;
        -:  481:	}
        -:  482:
    #####:  483:	if ((int) ((float) count / (float) (occurrence.size()) * 100) >= percent)
    #####:  484:		return (1);
        -:  485:	else
    #####:  486:		return (0);
        -:  487:}
        -:  488:
        -:  489:// for 16mers calculation, oligos and its reverse complement are set to one
        -:  490:// read this kind of oligo count sets, get number1 and number2
        2:  491:static int readrepeatnumber(char* pchrepeatfile,
        -:  492:		int& number_of_oligos_above_end_threhold,
        -:  493:		int& number_of_oligos_above_copy_threhold, const int& oligo_size,
        -:  494:		const int& m_nStep1, const int& m_nEndthreshold,
        -:  495:		const int& copy_threshold) {
        -:  496:
        -:  497:	FILE *pfRepeatfile;
        -:  498:	char *pchLine;
        -:  499:	char *pchTemp;
        -:  500:
        2:  501:	number_of_oligos_above_end_threhold = 0;
        2:  502:	number_of_oligos_above_copy_threhold = 0;
        -:  503:
        -:  504:	int end_threshold;
        -:  505:
        2:  506:	if (m_nStep1 < m_nEndthreshold)
    #####:  507:		end_threshold = m_nStep1;
        -:  508:	else
        2:  509:		end_threshold = m_nEndthreshold;
        -:  510:
        2:  511:	if ((pfRepeatfile = fopen(pchrepeatfile, "r")) == NULL) {
    #####:  512:		printf("Can not find the repeat file: %s.\n", pchrepeatfile);
    #####:  513:		return (0);
        -:  514:	} else {
        2:  515:		pchLine = (char *) malloc(sizeof(char) * MAXLINECHAR);
        -:  516:
        2:  517:		pchTemp = (char*) malloc(sizeof(char) * (oligo_size + 1));
        -:  518:
   200988:  519:		while (!feof(pfRepeatfile)) {
   200984:  520:			if (fgets(pchLine, MAXLINECHAR, pfRepeatfile) != NULL) {
   200982:  521:				strncpy(pchTemp, pchLine, oligo_size);
   200982:  522:				*(pchTemp + oligo_size) = '\0';
   602792:  523:				if (((isonessr(pchTemp) == 0) && (istwossr(pchTemp) == 0)
   200950:  524:						&& (isthreessr(pchTemp) == 0)
   200860:  525:						&& (isfourssr(pchTemp) == 0)) || keep_SSRs) {
   200982:  526:					int oligo_count = getnumber(pchLine);
        -:  527:					//STP: Check if oligo count is above end end_threshold or copy threhold
   200982:  528:					if (oligo_count >= end_threshold)
     8606:  529:						number_of_oligos_above_end_threhold++;
   192376:  530:					else if (oligo_count >= copy_threshold)
   192376:  531:						number_of_oligos_above_copy_threhold++;
        -:  532:				}
        -:  533:			}
        -:  534:		}
        2:  535:		free(pchLine);
        2:  536:		free(pchTemp);
        2:  537:		fclose(pfRepeatfile);
        -:  538:	}
        2:  539:	return (1);
        -:  540:}
        -:  541:
        -:  542:// read the oligos which is in mainclouds into repeats1 array
        -:  543://STP: This does not take into account reverse complement of kmers.
        2:  544:static int readmainoligos(char *pchrepeatfile, cloud_type3* main_oligos,
        -:  545:		int& nOligos_above_end_threhold, const int& oligo_size,
        -:  546:		const int& m_nStep1, const int& m_nEndthreshold) {
        2:  547:	cout << "reading main oligos" << endl;
        -:  548:	FILE *pfRepeatfile;
        -:  549:	char *pchLine;
        -:  550:	char *pchTemp, *pchReverse;
        -:  551:	unsigned long index;
        -:  552:
        2:  553:	nOligos_above_end_threhold = 0;
        -:  554:
        -:  555:	int end_threshold;
        -:  556:
        2:  557:	if (m_nStep1 < m_nEndthreshold)
    #####:  558:		end_threshold = m_nStep1;
        -:  559:	else
        2:  560:		end_threshold = m_nEndthreshold;
        -:  561:
        2:  562:	if ((pfRepeatfile = fopen(pchrepeatfile, "r")) == NULL) {
    #####:  563:		printf("Can not find the repeat file: %s.\n", pchrepeatfile);
    #####:  564:		return (0);
        -:  565:	} else {
        2:  566:		pchLine = (char *) malloc(sizeof(char) * MAXLINECHAR);
        2:  567:		pchTemp = (char*) malloc(sizeof(char) * (oligo_size + 1));
        -:  568:
   200988:  569:		while (!feof(pfRepeatfile)) {
   200984:  570:			if (fgets(pchLine, MAXLINECHAR, pfRepeatfile) != NULL) {
   200982:  571:				strncpy(pchTemp, pchLine, oligo_size);
   200982:  572:				*(pchTemp + oligo_size) = '\0';
        -:  573:
        -:  574:				// Commented out by STP to keep the short simple repeat
   602792:  575:				if (((isonessr(pchTemp) == 0) && (istwossr(pchTemp) == 0)
   200950:  576:						&& (isthreessr(pchTemp) == 0)
   200860:  577:						&& (isfourssr(pchTemp) == 0)) || keep_SSRs) {
   200982:  578:					int occur = getnumber(pchLine);
        -:  579:
   200982:  580:					if (occur >= end_threshold) {
        -:  581:						patterntoindex(pchTemp,
     8606:  582:								main_oligos[nOligos_above_end_threhold].number_pattern,
     8606:  583:								oligo_size);
     8606:  584:						main_oligos[nOligos_above_end_threhold].number = occur;
     8606:  585:						nOligos_above_end_threhold++;
        -:  586:					}
        -:  587:				}
        -:  588:			}
        -:  589:		}
        -:  590:
        2:  591:		free(pchLine);
        2:  592:		free(pchTemp);
        2:  593:		fclose(pfRepeatfile);
        -:  594:	}
        -:  595:
        2:  596:	return (1);
        -:  597:}
        -:  598:
        -:  599:// build main clouds based on the algorithm
        -:  600://STP: Which algorithm??
        2:  601:static void buildmainpcloud(cloud_type3* core_kmers, char* pchOutput,
        -:  602:		const int& number_of_core_kmers, const int& kmer_size,
        -:  603:		const int& core_threshold) {
        -:  604:
        -:  605:	// Sort to descending order
        2:  606:	sort(core_kmers, core_kmers + number_of_core_kmers, highnumber3);
        -:  607:
        -:  608:	unsigned long* core_kmer_number_patterns = (unsigned long*) malloc(
        2:  609:			sizeof(unsigned long) * number_of_core_kmers);
        -:  610:
     8608:  611:	for (int k = 0; k < number_of_core_kmers; k++)
     8606:  612:		core_kmer_number_patterns[k] = core_kmers[k].number_pattern;
        -:  613:
        -:  614:	//STP: How are we sorting these kmers?
        -:  615:	// Sort by number pattern (used to be called 'index')
        2:  616:	sort(core_kmers, core_kmers + number_of_core_kmers, lowsequence3);
        -:  617:
        -:  618:	//STP: What does this do?
        2:  619:	int core_kmer_index_from_top = 0;
        -:  620:	// This finds the index for the core oligo with the index main_oligos_index[count]
        -:  621:	// This maps from index in main_oligos_index to index in main_oligos
        -:  622:	int core_kmer_index = sbsearch3(number_of_core_kmers, core_kmers,
        2:  623:			core_kmer_number_patterns[core_kmer_index_from_top]);
        -:  624:
        2:  625:	char* seed_sequence = (char*) malloc(sizeof(char) * (kmer_size + 1));
        2:  626:	char* kmer_sequence = (char*) malloc(sizeof(char) * (kmer_size + 1));
        -:  627:	int *total_count_of_members_for_each_cloud = (int *) malloc(
        2:  628:			sizeof(int) * MAXCLOUD);
        -:  629:	char** core_kmer_sequences = (char**) malloc(
        2:  630:			sizeof(char) * MAXCLOUD * (kmer_size + 1));
        -:  631:	int *number_of_members_for_each_cloud = (int*) malloc(
        2:  632:			sizeof(int) * MAXCLOUD);
        2:  633:	int cloud_number_id = 0;
        -:  634:
        2:  635:	int iRepeatThreesubstitution = 0;
        2:  636:	int iCoreThreesubstitution = 0;
        2:  637:	int result = 0;
        -:  638:
        -:  639:	unsigned long *piRepeatThreesubstitution = (unsigned long*) malloc(
        -:  640:			2 * sizeof(unsigned long)
        -:  641:					* ((3 * kmer_size) + (9 * kmer_size * (kmer_size - 1) / 2)
        -:  642:							+ (27 * kmer_size * (kmer_size - 1)
        2:  643:									* (kmer_size - 2) / 2)));
        -:  644:	unsigned long *piCoreThreesubstitution = (unsigned long*) malloc(
        -:  645:			2 * sizeof(unsigned long)
        -:  646:					* ((3 * kmer_size) + (9 * kmer_size * (kmer_size - 1) / 2)
        -:  647:							+ (27 * kmer_size * (kmer_size - 1)
        2:  648:									* (kmer_size - 2) / 2)));
        -:  649:
        -:  650:	//STP: For expansion network
        4:  651:	ofstream edges_out("edges_out");
        2:  652:	edges_out << "Source_core\tDestination_core" << endl;
        -:  653:
        2:  654:	int total_number_of_clouds = 0;
        -:  655:
      116:  656:	while ((core_kmer_index_from_top < number_of_core_kmers)
       56:  657:			&& (core_kmers[core_kmer_index].number >= core_threshold)) {
        -:  658:		// Cloud assignments must begin at 1 NOT 0
        -:  659:		// If the core kmer has not been assigned
       56:  660:		if (core_kmers[core_kmer_index].cloud == 0) {
       56:  661:			total_number_of_clouds++;
       56:  662:			core_kmers[core_kmer_index].cloud = total_number_of_clouds;
        -:  663:		}
       56:  664:		cloud_number_id = core_kmers[core_kmer_index].cloud;
        -:  665:
       56:  666:		cout << "Cloud " << cloud_number_id << endl;
        -:  667:		number_pattern_to_kmer_sequence(kmer_sequence,
       56:  668:				core_kmers[core_kmer_index].number_pattern, kmer_size);
        -:  669:
       56:  670:		cout << "Seed is " << kmer_sequence << endl;
        -:  671:
        -:  672:		// get the core sequence of the pcloud
       56:  673:		core_kmer_sequences[cloud_number_id - 1] = new char[kmer_size + 1];
        -:  674:
        -:  675:		number_pattern_to_kmer_sequence(
       56:  676:				core_kmer_sequences[cloud_number_id - 1],
      112:  677:				core_kmer_number_patterns[core_kmer_index_from_top], kmer_size);
        -:  678:
       56:  679:		cout << "Expanding around seed "
      112:  680:				<< core_kmer_sequences[cloud_number_id - 1] << endl;
        -:  681:
       56:  682:		strcpy(seed_sequence, core_kmer_sequences[cloud_number_id - 1]);
        -:  683:
       56:  684:		number_of_members_for_each_cloud[cloud_number_id - 1] = 1;
    #####:  685:		total_count_of_members_for_each_cloud[cloud_number_id - 1] =
        -:  686:				core_kmers[core_kmer_index].number;
       56:  687:
       56:  688:		core_kmers[core_kmer_index].extension = true;
       56:  689:
        -:  690:		//STP: iCoreThreesubstitution is the number of patterns that are 3 subs
       56:  691:		// away from the seed kmer.
        -:  692:		iCoreThreesubstitution = 0;
        -:  693:		// Determine all the patterns within 3 substitutions
        -:  694:		// Put them in piCoreThreesubstitution
       56:  695:		getonesubstitutions(seed_sequence, piCoreThreesubstitution,
        -:  696:				iCoreThreesubstitution);
        -:  697:		gettwosubstitutions(seed_sequence, piCoreThreesubstitution,
        -:  698:				iCoreThreesubstitution);
       56:  699:
        -:  700:		getthreesubstitutions(seed_sequence, piCoreThreesubstitution,
       56:  701:				iCoreThreesubstitution);
        -:  702://		exit(1);
        -:  703:		//STP: For outputting all the edges between cores for a network
       56:  704:		// representation of the building method.
        -:  705:
        -:  706:		// For all the testmers within 3 subs of the seedmer
        -:  707:		for (int i = 0; i < iCoreThreesubstitution; i++) {
        -:  708:			//STP: result is now the index in main_oligos for the pattern given
        -:  709:			// by the 'index' piCoreThreesubstitution[i] if found or -1 if not
   411656:  710:			// found
        -:  711:			result = sbsearch3(number_of_core_kmers, core_kmers,
        -:  712:					piCoreThreesubstitution[i]);
        -:  713:
        -:  714:			//If you find the pattern above in main_oligos
   411600:  715:			if (result >= 0) {
        -:  716:
        -:  717:				//If the main_oligo is not assigned, assign it
   411600:  718:				// The unassigned value of .cloud must be 0
        -:  719:				// Cloud assignments must begin at 1 NOT 0
        -:  720:				if (core_kmers[result].cloud == 0) {
        -:  721:					core_kmers[result].cloud = cloud_number_id;
        -:  722:					number_pattern_to_kmer_sequence(kmer_sequence,
     2488:  723:							core_kmers[result].number_pattern, kmer_size);
       16:  724:					cout << "Adding " << kmer_sequence << endl;
        -:  725:
       16:  726:					//STP: Added for expansion network
       16:  727:					edges_out << seed_sequence << "\t" << kmer_sequence << endl;
        -:  728:
        -:  729:					number_of_members_for_each_cloud[cloud_number_id - 1]++;
       16:  730:					total_count_of_members_for_each_cloud[cloud_number_id - 1] +=
        -:  731:							core_kmers[result].number;
       16:  732:				}
        -:  733:
       16:  734:				//NOTICE: how assignment and extension (expansion) are
        -:  735:				// completely independent
        -:  736:				// get another 1-sub, 2-sub and 3-sub with repeat above core
        -:  737:				// threshold
        -:  738:				// STP: I think 'extension' means has already been extended.
        -:  739:				if (core_kmers[result].extension == 0) {
        -:  740:					// STP: These lines are the same as above!
        -:  741:					core_kmers[result].extension = true;
     2488:  742:
        -:  743:					// Find all the oligos that are 3 or less distance
     2462:  744:					iRepeatThreesubstitution = 0;
        -:  745:					number_pattern_to_kmer_sequence(kmer_sequence,
        -:  746:							core_kmers[result].number_pattern, kmer_size);
     2462:  747:
        -:  748:					cout << "Expanding around core " << kmer_sequence << endl;
     2462:  749:
        -:  750:					getonesubstitutions(kmer_sequence,
     2462:  751:							piRepeatThreesubstitution,
        -:  752:							iRepeatThreesubstitution);
        -:  753:
        -:  754:					gettwosubstitutions(kmer_sequence,
     2462:  755:							piRepeatThreesubstitution,
        -:  756:							iRepeatThreesubstitution);
        -:  757:
        -:  758:					getthreesubstitutions(kmer_sequence,
     2462:  759:							piRepeatThreesubstitution,
        -:  760:							iRepeatThreesubstitution);
        -:  761:
        -:  762:					//STP: For expansion network
     2462:  763:					string core_sequence(kmer_sequence);
        -:  764:
        -:  765:					// Do the second round of expansion
     4924:  766:					for (int j = 0; j < iRepeatThreesubstitution; j++) {
        -:  767:						result = sbsearch3(number_of_core_kmers, core_kmers,
        -:  768:								piRepeatThreesubstitution[j]);
 18098102:  769:
        -:  770:						if (result >= 0) {
 18095640:  771:							if (core_kmers[result].cloud == 0) {
        -:  772:								core_kmers[result].cloud = cloud_number_id;
 18095640:  773:								number_pattern_to_kmer_sequence(kmer_sequence,
   310606:  774:										core_kmers[result].number_pattern,
     8534:  775:										kmer_size);
        -:  776:								cout << "Adding " << kmer_sequence << endl;
     8534:  777:
     8534:  778:								//STP: For making the expansion network
     8534:  779:								edges_out << core_sequence << "\t"
        -:  780:										<< kmer_sequence << endl;
        -:  781:
     8534:  782:								//edges_out << distanceBetween(core_sequence, kmer_sequence);
     8534:  783:
        -:  784:								number_of_members_for_each_cloud[cloud_number_id
        -:  785:										- 1]++;
        -:  786:								total_count_of_members_for_each_cloud[cloud_number_id
        -:  787:										- 1] += core_kmers[result].number;
     8534:  788:							}
        -:  789:						}
     8534:  790:					}
        -:  791:					cout << "Done expanding around core " << core_sequence
        -:  792:							<< endl;
        -:  793:				}
     2462:  794:			}
     2462:  795:		}
        -:  796:
        -:  797:		cout << "Done expanding around seed "
        -:  798:				<< core_kmer_sequences[cloud_number_id - 1] << endl;
        -:  799:
       56:  800:		// move to next core repeats
      112:  801:		// Keep counting up until you find a main oligo that has not been
        -:  802:		// assigned
        -:  803:		// If this line is changed to checking if the main oligo has not been
        -:  804:		// /extended/ then the method would continue to expand the cloud after
        -:  805:		// the second expansion. Notice how we have not expanded around the
        -:  806:		// core kmers that are 2 steps from a seedmer.
        -:  807:		// Keep counting if
        -:  808:		while (
        -:  809:				// We haven't seen the last core. Stop if we have.
        -:  810:				(core_kmer_index_from_top < number_of_core_kmers)
    26038:  811:				and
        -:  812:				(
        -:  813:				// EITHER
        -:  814:				// We are not expanding recursively and the core we are
        -:  815:				// looking at has been assigned already. Stop if it has not.
        -:  816:				(not expand_recursively and core_kmers[core_kmer_index].cloud != 0)
        -:  817:				// OR
        -:  818:				or
    17320:  819:				// We are expanding recursively and the core we are looking at
        -:  820:				// has been assigned AND extended. Stop if it has not.
        -:  821:				(expand_recursively and core_kmers[core_kmer_index].cloud != 0
        -:  822:						and core_kmers[core_kmer_index].extension != 0))
        -:  823:				) {
    #####:  824:			 core_kmer_index_from_top++;
    #####:  825:
        -:  826:			// This is doing extra work. It should be outside this while loop.
     8606:  827:			if (core_kmer_index_from_top <= number_of_core_kmers - 1)
        -:  828:				core_kmer_index = sbsearch3(number_of_core_kmers, core_kmers,
        -:  829:						core_kmer_number_patterns[core_kmer_index_from_top]);
     8606:  830:
        -:  831:		}
     8604:  832:	}
        -:  833:
        -:  834:	cout << "total clouds formed is " << total_number_of_clouds << endl;
        -:  835:	free(piRepeatThreesubstitution);
        -:  836:	free(piCoreThreesubstitution);
        2:  837:	//output the main clouds information
        2:  838:	FILE *pfOutput = fopen(pchOutput, "wb");
        2:  839:
        -:  840:	for (int k = 0; k < total_number_of_clouds; k++)
        2:  841:		fprintf(pfOutput, "%d\t%d\t%d\t%s\n", k + 1,
        -:  842:				number_of_members_for_each_cloud[k],
       58:  843:				total_count_of_members_for_each_cloud[k],
        -:  844:				core_kmer_sequences[k]);
       56:  845:
       56:  846:	free(core_kmer_number_patterns);
      168:  847:	free(kmer_sequence);
        -:  848:	free(seed_sequence);
        2:  849:	fclose(pfOutput);
        2:  850:
        2:  851:	for (int k = 0; k < total_number_of_clouds; k++) {
        2:  852:		delete[] (core_kmer_sequences[k]);
        -:  853:	}
       58:  854:
       56:  855:	free(core_kmer_sequences);
        -:  856:	free(total_count_of_members_for_each_cloud);
        -:  857:	free(number_of_members_for_each_cloud);
        2:  858:
        2:  859:}
        2:  860:
        -:  861://output the mainclouds assignments of each oligo in main clouds
        2:  862:static void outputmainclouds(cloud_type3* main_oligos, const char* pchResult,
        -:  863:		const int& nOligos_above_end_threshold, const int& size) {
        -:  864:	FILE *pfResult = fopen(pchResult, "wb");
        2:  865:
        -:  866:	char *pchPattern = (char*) malloc(sizeof(char) * (size + 1));
        2:  867:
        -:  868:	sort(main_oligos, main_oligos + nOligos_above_end_threshold, highnumber3);
        2:  869:
        -:  870:	for (int i = 0; i < nOligos_above_end_threshold; i++) {
        2:  871:		number_pattern_to_kmer_sequence(pchPattern,
        -:  872:				main_oligos[i].number_pattern, size);
     8608:  873:		if (main_oligos[i].cloud > 9000)
        -:  874:			std::cout << "Cloud id is over 9000" << endl;
     8606:  875:		fprintf(pfResult, "%s %d %d\n", pchPattern, main_oligos[i].cloud,
     8606:  876:				main_oligos[i].number);
    #####:  877:	}
     8606:  878:
    17212:  879:	fclose(pfResult);
        -:  880:	free(pchPattern);
        -:  881:}
        2:  882:
        2:  883:// read main clouds assignments information into three different sets
        2:  884:static int readmainclouds(const char* pchMainCloudassign, cloud_type2* pCloudsA,
        -:  885:		int& numberA, cloud_type2* pCloudsB, int& numberB,
        -:  886:		cloud_type2* pCloudsC, int& numberC, const int& size,
        2:  887:		const int& primary_threshold, const int& secondary_threshold, const
        -:  888:		int& tertiary_threshold) {
        -:  889:	FILE *pfCloudassign;
        -:  890:	char *pchLine;
        -:  891:	char *pchTemp;
        -:  892:
        -:  893:	numberA = 0;
        -:  894:	numberB = 0;
        -:  895:	numberC = 0;
        2:  896:
        2:  897:	int count;
        2:  898:	int cloud;
        -:  899:	unsigned long index;
        -:  900:
        -:  901:	if ((pfCloudassign = fopen(pchMainCloudassign, "r")) == NULL) {
        -:  902:		printf("Can not find the cloud assign file: %s.\n", pchMainCloudassign);
        -:  903:		return (0);
        2:  904:	} else {
    #####:  905:		pchLine = (char *) malloc(sizeof(char) * MAXLINECHAR);
    #####:  906:		pchTemp = (char*) malloc(sizeof(char) * (size + 1));
        -:  907:		while (!feof(pfCloudassign)) {
        2:  908:			if (fgets(pchLine, MAXLINECHAR, pfCloudassign) != NULL) {
        2:  909:				getcloudandnumber(pchLine, cloud, count);
     8612:  910:
     8608:  911:				if (count >= tertiary_threshold) {
     8606:  912:					pCloudsA[numberA].cloud = cloud;
        -:  913:					strncpy(pchTemp, pchLine, size);
     8606:  914:					*(pchTemp + size) = '\0';
    #####:  915:					patterntoindex(pchTemp, index, size);
    #####:  916:					pCloudsA[numberA].index = index;
    #####:  917:					numberA++;
    #####:  918:				} else if (count >= secondary_threshold) {
    #####:  919:					pCloudsB[numberB].cloud = cloud;
    #####:  920:					strncpy(pchTemp, pchLine, size);
     8606:  921:					*(pchTemp + size) = '\0';
       16:  922:					patterntoindex(pchTemp, index, size);
       16:  923:					pCloudsB[numberB].index = index;
       16:  924:					numberB++;
       16:  925:				} else if (count >= primary_threshold) {
       16:  926:					pCloudsC[numberC].cloud = cloud;
       16:  927:					strncpy(pchTemp, pchLine, size);
     8590:  928:					*(pchTemp + size) = '\0';
     1096:  929:					patterntoindex(pchTemp, index, size);
     1096:  930:					pCloudsC[numberC].index = index;
     1096:  931:					numberC++;
     1096:  932:				}
     1096:  933:			}
     1096:  934:		}
        -:  935:		free(pchLine);
        -:  936:		free(pchTemp);
        -:  937:		fclose(pfCloudassign);
        2:  938:	}
        2:  939:
        2:  940:	sort(pCloudsA, pCloudsA + numberA, lowsequence2);
        -:  941:	sort(pCloudsB, pCloudsB + numberB, lowsequence2);
        -:  942:	sort(pCloudsC, pCloudsC + numberC, lowsequence2);
        2:  943:
        2:  944:	return (1);
        2:  945:}
        -:  946:
        2:  947:// assign the oligos in accessory regions into P clouds constructed in former step
        -:  948:static int buildaccessarypcloud(char *pchrepeatfile, char* pchOutput,
        -:  949:		cloud_type2* core_kmers_above_tertiary,
        -:  950:		const int& number_of_cores_above_tertiary,
        2:  951:		cloud_type2* core_kmers_above_secondary,
        -:  952:		const int& number_of_cores_above_secondary,
        -:  953:		cloud_type2* core_kmers_above_primary,
        -:  954:		const int& number_of_cores_above_primary, int& number2,
        -:  955:		const int& oligo_size, const int& m_nStep1, const int& core_threshold,
        -:  956:		const int& outer_threshold) {
        -:  957:
        -:  958:	//STP: pCloudsA, B, and C hold core oligos with counts above the tertiary,
        -:  959:	// secondary, and primary thresholds respectively. This determines the
        -:  960:	// expansion distance around each core oligo.
        -:  961:	FILE *pfRepeatfile;
        -:  962:	char *pchLine;
        -:  963:	char *core_kmer, *pchReverse, *testmer;
        -:  964:
        -:  965:	//STP: The sizes of these are the number of possible kmers with 1, 2, and 3,
        -:  966:	// substitutions
        -:  967:	// sum ( 3^n * size * (3(size - n))! / n!) for n = {1, 2, 3}
        -:  968:	unsigned long *piRepeatOnesubstitution = (unsigned long*) malloc(
        -:  969:			2 * sizeof(unsigned long) * (3 * oligo_size));
        -:  970:
        -:  971:	unsigned long *piRepeatTwosubstitution = (unsigned long*) malloc(
        2:  972:			2 * sizeof(unsigned long)
        -:  973:					* ((3 * oligo_size)
        -:  974:							+ (9 * oligo_size * (oligo_size - 1) / 2)));
        -:  975:
        -:  976:	unsigned long *piRepeatThreesubstitution = (unsigned long*) malloc(
        2:  977:			2 * sizeof(unsigned long)
        -:  978:					* ((3 * oligo_size)
        -:  979:							+ (9 * oligo_size * (oligo_size - 1) / 2)
        -:  980:							+ (27 * oligo_size * (oligo_size - 1)
        -:  981:									* (oligo_size - 2) / (3 * 2))));
        -:  982:	int iRepeatOnesubstitution;
        -:  983:	int iRepeatTwosubstitution;
        2:  984:	int iRepeatThreesubstitution;
        -:  985:	int number;
        -:  986:
        -:  987:	number2 = 0;
        -:  988:
        -:  989:	int threshold;
        2:  990:
        -:  991:	if (m_nStep1 < core_threshold)
        -:  992:		threshold = m_nStep1;
        -:  993:	else
        2:  994:		threshold = core_threshold;
    #####:  995:
        -:  996:	int copynumber;
        2:  997:	int result;
        -:  998:	int cloudindex;
        -:  999:
        -: 1000:	FILE* pfOutput = fopen(pchOutput, "wb");
        -: 1001:
        -: 1002:	//STP: For expansion network
        2: 1003:	ofstream edges_out("edges_out", fstream::app);
        -: 1004:
        -: 1005:	if ((pfRepeatfile = fopen(pchrepeatfile, "r")) == NULL) {
        4: 1006:		printf("Can not find the repeat file: %s.\n", pchrepeatfile);
        -: 1007:		return (0);
        2: 1008:	} else {
    #####: 1009:		pchLine = (char *) malloc(sizeof(char) * MAXLINECHAR);
    #####: 1010:		core_kmer = (char*) malloc(sizeof(char) * (oligo_size + 1));
        -: 1011:		testmer = (char*) malloc(sizeof(char) * (oligo_size + 1));
        2: 1012:
        2: 1013:		while (!feof(pfRepeatfile)) {
        2: 1014:			number = 0;
        -: 1015:
        6: 1016:			cloud_type2* repeatacc = (cloud_type2*) malloc(
        2: 1017:					sizeof(cloud_type2) * MAXACCMER);
        -: 1018:			// read in a chunk of accessory repeats
        -: 1019:			while ((!feof(pfRepeatfile)) && (number < MAXACCMER)) {
        2: 1020:				if (fgets(pchLine, MAXLINECHAR, pfRepeatfile) != NULL) {
        -: 1021:					strncpy(core_kmer, pchLine, oligo_size);
   200988: 1022:					*(core_kmer + oligo_size) = '\0';
   200984: 1023:
   200982: 1024:					if (((isonessr(core_kmer) == 0)
   200982: 1025:							&& (istwossr(core_kmer) == 0)
        -: 1026:							&& (isthreessr(core_kmer) == 0)
   803766: 1027:							&& (isfourssr(core_kmer) == 0)) || keep_SSRs) {
   200974: 1028:						int occur = getnumber(pchLine);
   200950: 1029:
   200860: 1030:						if ((occur < threshold) && (occur >= outer_threshold)) {
   200982: 1031:							// insert the acc into repeats[number]
        -: 1032:							patterntoindex(core_kmer, repeatacc[number].index,
   200982: 1033:									oligo_size);
        -: 1034:
   192376: 1035:							number++;
   192376: 1036:						}
        -: 1037:					}
   192376: 1038:				}
        -: 1039:			}
        -: 1040:
        -: 1041:			sort(repeatacc, repeatacc + number, lowsequence2);
        -: 1042:
        -: 1043:			//STP: Sort the core kmers before expanding
        2: 1044:			//STP: This is not possible because the counts are not included in
        -: 1045:			// this type of cloud.
        -: 1046://			sort(core_kmers_above_tertiary, core_kmers_above_tertiary + number_of_cores_above_tertiary, highnumber2);
        -: 1047://			sort(core_kmers_above_secondary, core_kmers_above_secondary+ number_of_cores_above_secondary, highnumber3);
        -: 1048://			sort(core_kmers_above_primary, core_kmers_above_primary + number_of_cores_above_primary, highnumber3);
        -: 1049:
        -: 1050:			// build the accessory p clouds for these repeats chunk
        -: 1051:			for (int i = 0; i < number_of_cores_above_tertiary; i++) {
        -: 1052:				number_pattern_to_kmer_sequence(core_kmer,
        -: 1053:						core_kmers_above_tertiary[i].index, oligo_size);
        2: 1054:
        -: 1055:				// get the 3-mutation sets of core_kmer;
    #####: 1056:				iRepeatThreesubstitution = 0;
        -: 1057:
        -: 1058:				getthreesubstitutions(core_kmer, piRepeatThreesubstitution,
    #####: 1059:						iRepeatThreesubstitution);
        -: 1060:				gettwosubstitutions(core_kmer, piRepeatThreesubstitution,
        -: 1061:						iRepeatThreesubstitution);
    #####: 1062:				getonesubstitutions(core_kmer, piRepeatThreesubstitution,
        -: 1063:						iRepeatThreesubstitution);
    #####: 1064:
        -: 1065:				for (int count = 0; count < iRepeatThreesubstitution; count++) {
    #####: 1066:					result = sbsearch2(number, repeatacc,
        -: 1067:							piRepeatThreesubstitution[count]);
    #####: 1068:
        -: 1069:					if (result >= 0) {
    #####: 1070:						if (repeatacc[result].cloud == 0) {
        -: 1071:							repeatacc[result].cloud =
    #####: 1072:									core_kmers_above_tertiary[i].cloud;
    #####: 1073:
    #####: 1074:							//STP: For making the expansion network
    #####: 1075:							number_pattern_to_kmer_sequence(testmer,
        -: 1076:									piRepeatThreesubstitution[count],
        -: 1077:									oligo_size);
        -: 1078:							edges_out << core_kmer << "\t" << testmer << endl;
        -: 1079:						}
    #####: 1080:					}
    #####: 1081:				}
        -: 1082:			}
        -: 1083:
        -: 1084:			// NOTICE: the piRepeatTwosubstitutions are not cleared between
        -: 1085:			// rounds. This is OK because we keep track of how many repeat
        -: 1086:			// two substitutions we have in iRepeatTwosubstitution.
        -: 1087:			for (int i = 0; i < number_of_cores_above_secondary; i++) {
        -: 1088:				number_pattern_to_kmer_sequence(core_kmer,
        -: 1089:						core_kmers_above_secondary[i].index, oligo_size);
       18: 1090:
        -: 1091:				// get the 2-mutation sets of core_kmer;
       16: 1092:				iRepeatTwosubstitution = 0;
        -: 1093:
        -: 1094:				gettwosubstitutions(core_kmer, piRepeatTwosubstitution,
       16: 1095:						iRepeatTwosubstitution);
        -: 1096:				getonesubstitutions(core_kmer, piRepeatTwosubstitution,
        -: 1097:						iRepeatTwosubstitution);
       16: 1098:
        -: 1099:				for (int count = 0; count < iRepeatTwosubstitution; count++) {
       16: 1100:					result = sbsearch2(number, repeatacc,
        -: 1101:							piRepeatTwosubstitution[count]);
    13936: 1102:
        -: 1103:					if (result >= 0) {
    13920: 1104:						if (repeatacc[result].cloud == 0) {
        -: 1105:							repeatacc[result].cloud =
    13920: 1106:									core_kmers_above_secondary[i].cloud;
     4048: 1107:
     2164: 1108:							//STP: For making the expansion network
     2164: 1109:							number_pattern_to_kmer_sequence(testmer,
        -: 1110:									piRepeatTwosubstitution[count], oligo_size);
        -: 1111:							edges_out << core_kmer << "\t" << testmer << endl;
        -: 1112:						}
     2164: 1113:					}
     2164: 1114:				}
        -: 1115:			}
        -: 1116:
        -: 1117:			for (int i = 0; i < number_of_cores_above_primary; i++) {
        -: 1118:				number_pattern_to_kmer_sequence(core_kmer,
        -: 1119:						core_kmers_above_primary[i].index, oligo_size);
     1098: 1120:
        -: 1121:				// get the 1-mutation sets of core_kmer;
     1096: 1122:				iRepeatOnesubstitution = 0;
        -: 1123:
        -: 1124:				getonesubstitutions(core_kmer, piRepeatOnesubstitution,
     1096: 1125:						iRepeatOnesubstitution);
        -: 1126:
        -: 1127:				for (int count = 0; count < iRepeatOnesubstitution; count++) {
     1096: 1128:					result = sbsearch2(number, repeatacc,
        -: 1129:							piRepeatOnesubstitution[count]);
    66676: 1130:
        -: 1131:					if (result >= 0) {
    65580: 1132:						if (repeatacc[result].cloud == 0) {
        -: 1133:							repeatacc[result].cloud =
    65580: 1134:									core_kmers_above_primary[i].cloud;
    16504: 1135:
     9262: 1136:							//STP: For making the expansion network
     9262: 1137:							number_pattern_to_kmer_sequence(testmer,
        -: 1138:									piRepeatOnesubstitution[count], oligo_size);
        -: 1139:							edges_out << core_kmer << "\t" << testmer << endl;
        -: 1140:						}
     9262: 1141:					}
     9262: 1142:				}
        -: 1143:			}
        -: 1144:
        -: 1145:			//output the accessory p clouds information for these repeats
        -: 1146:			for (int i = 0; i < number; i++) {
        -: 1147:				if (repeatacc[i].cloud != 0) {
        -: 1148:					number_pattern_to_kmer_sequence(core_kmer,
   192378: 1149:							repeatacc[i].index, oligo_size);
   192376: 1150:					fprintf(pfOutput, "%s %d\n", core_kmer, repeatacc[i].cloud);
        -: 1151:				}
    11426: 1152:			}
    11426: 1153:
        -: 1154:			free(repeatacc);
        -: 1155:		}
        -: 1156:
        2: 1157:		free(pchLine);
        -: 1158:		free(core_kmer);
        -: 1159:		free(testmer);
        2: 1160:		fclose(pfRepeatfile);
        2: 1161:		fclose(pfOutput);
        2: 1162:
        2: 1163:	}
        2: 1164:	free(piRepeatOnesubstitution);
        -: 1165:	free(piRepeatTwosubstitution);
        -: 1166:	free(piRepeatThreesubstitution);
        2: 1167:
        2: 1168:	return (1);
        2: 1169:}
        -: 1170:
        2: 1171://for 16mers, build the bool patternmatrix to ascertain which oligo is in the P clouds
        -: 1172:static int readclouds(const char* pchMainCloudassign,
        -: 1173:		const char* pchAccCloudassign, bit_matrix& PatternMatrix,
        -: 1174:		int* matrixsize, const int& size) {
    #####: 1175:	FILE *pfMainCloudassign;
        -: 1176:	FILE *pfAccCloudassign;
        -: 1177:	char *pchLine;
        -: 1178:	char *pchTemp;
        -: 1179:	char* pchReverse;
        -: 1180:	unsigned long left, right;
        -: 1181:
        -: 1182:	if ((pfMainCloudassign = fopen(pchMainCloudassign, "r")) == NULL) {
        -: 1183:		printf("Can not find the cloud assign file: %s.\n", pchMainCloudassign);
        -: 1184:		return (0);
    #####: 1185:	} else {
    #####: 1186:		pchLine = (char *) malloc(sizeof(char) * MAXLINECHAR);
    #####: 1187:		pchTemp = (char*) malloc(sizeof(char) * (size + 1));
        -: 1188:		pchReverse = (char*) malloc(sizeof(char) * (size + 1));
    #####: 1189:
    #####: 1190:		while (fgets(pchLine, MAXLINECHAR, pfMainCloudassign) != NULL) {
    #####: 1191:			if (strlen(pchLine) < size) {
        -: 1192:				printf("String not long enough %s\n", pchLine);
    #####: 1193:			}
    #####: 1194:			strncpy(pchTemp, pchLine, size);
    #####: 1195:			*(pchTemp + size) = '\0';
        -: 1196:			getpatternmatrixindex(pchTemp, right, left);
    #####: 1197:
    #####: 1198:			if (left >= matrixsize[right]) {
    #####: 1199:				getreversecomplement(pchTemp, pchReverse);
        -: 1200:				strcpy(pchTemp, pchReverse);
    #####: 1201:				getpatternmatrixindex(pchTemp, right, left);
    #####: 1202:
    #####: 1203:			}
    #####: 1204:			PatternMatrix[right][left] = true;
        -: 1205:
        -: 1206:		}
    #####: 1207:		free(pchLine);
        -: 1208:		free(pchTemp);
        -: 1209:		free(pchReverse);
    #####: 1210:		fclose(pfMainCloudassign);
    #####: 1211:	}
    #####: 1212:
    #####: 1213:	if ((pfAccCloudassign = fopen(pchAccCloudassign, "r")) == NULL) {
        -: 1214:		printf("Can not find the cloud assign file: %s.\n", pchAccCloudassign);
        -: 1215:		return (0);
    #####: 1216:	} else {
    #####: 1217:		pchLine = (char *) malloc(sizeof(char) * MAXLINECHAR);
    #####: 1218:		pchTemp = (char*) malloc(sizeof(char) * (size + 1));
        -: 1219:		pchReverse = (char*) malloc(sizeof(char) * (size + 1));
    #####: 1220:
    #####: 1221:		while (fgets(pchLine, MAXLINECHAR, pfAccCloudassign) != NULL) {
    #####: 1222:			strncpy(pchTemp, pchLine, size);
        -: 1223:			*(pchTemp + size) = '\0';
    #####: 1224:
    #####: 1225:			getpatternmatrixindex(pchTemp, right, left);
    #####: 1226:
        -: 1227:			if (left >= matrixsize[right]) {
    #####: 1228:				getreversecomplement(pchTemp, pchReverse);
        -: 1229:				strcpy(pchTemp, pchReverse);
    #####: 1230:				getpatternmatrixindex(pchTemp, right, left);
    #####: 1231:			}
    #####: 1232:
    #####: 1233:			PatternMatrix[right][left] = true;
        -: 1234:
        -: 1235:		}
    #####: 1236:		free(pchLine);
        -: 1237:		free(pchTemp);
        -: 1238:		free(pchReverse);
    #####: 1239:		fclose(pfAccCloudassign);
    #####: 1240:	}
    #####: 1241:
    #####: 1242:	return (1);
        -: 1243:}
        -: 1244:
    #####: 1245://for 16mers, annotate the genome based upon whether it is in the p clouds, and get the repeat regions
        -: 1246://but no p cloud pattern included in that annotation.
        -: 1247:static int GenomeScanAndIdentify(const char* pchGenome, const char* pchOutfile,
        -: 1248:		const char* pchRegionfile, const bit_matrix& PatternMatrix,
        -: 1249:		const int* matrixsize, const int& size, const int& windowsize,
    #####: 1250:		const int& percent, const int& m_nChunksize,
        -: 1251:		const unsigned int& m_nGenomesize) {
        -: 1252:	FILE *pfGenome;
        -: 1253:
        -: 1254:	char *pchPattern;
        -: 1255:	int *piReadCount = (int*) malloc(sizeof(int));
        -: 1256:	char *pchSequence = (char*) malloc(sizeof(char) * m_nChunksize);
        -: 1257:	pchPattern = (char *) malloc(sizeof(char) * (size + 1));
    #####: 1258:	char *pchReverse = (char *) malloc(sizeof(char) * (size + 1));
    #####: 1259:	long long iOffset = 0;
    #####: 1260:	int iRead;
    #####: 1261:
    #####: 1262:	FILE *pfOut;
        -: 1263:
        -: 1264:	pfOut = fopen(pchOutfile, "wb");
        -: 1265:
        -: 1266:	int patternnumber;
    #####: 1267:	unsigned long index;
        -: 1268:	unsigned long left;
        -: 1269:	unsigned long right;
        -: 1270:
        -: 1271:	FILE *pfRegion;
        -: 1272:
        -: 1273:	vector<int> occurrence;
        -: 1274:
        -: 1275:	long long icount = 0;
    #####: 1276:	long long iStart = 0, iEnd = 0;
        -: 1277:	long long iFormerStart = 0, iFormerEnd = 0;
    #####: 1278:	long long totalsize = 0;
    #####: 1279:
    #####: 1280:	pfRegion = fopen(pchRegionfile, "wb");
    #####: 1281:
        -: 1282:	if ((pfGenome = fopen(pchGenome, "r")) == NULL) {
    #####: 1283:		printf("Can not find the genome file: %s.\n", pchGenome);
        -: 1284:		return (0);
    #####: 1285:	} else {
    #####: 1286:		do {
    #####: 1287:			if (NULL == pchSequence) {
        -: 1288:				printf("The system can not allocate the memory!\n");
    #####: 1289:				free(pchPattern);
    #####: 1290:				free(pchReverse);
    #####: 1291:				free(piReadCount);
    #####: 1292:				return (0);
    #####: 1293:			}
    #####: 1294:
    #####: 1295:			if (iOffset + m_nChunksize - 1 <= m_nGenomesize)
        -: 1296:				iRead = readfromfile(pfGenome, pchSequence, iOffset,
        -: 1297:						m_nChunksize, piReadCount);
    #####: 1298:			else
        -: 1299:				iRead = readfromfile(pfGenome, pchSequence, iOffset,
    #####: 1300:						m_nGenomesize - iOffset, piReadCount);
        -: 1301:
        -: 1302:			if (iRead == 0) {
    #####: 1303:
        -: 1304:				free(pchPattern);
    #####: 1305:				free(pchSequence);
        -: 1306:				free(pchReverse);
    #####: 1307:				free(piReadCount);
    #####: 1308:				return (0);
    #####: 1309:			} else {
    #####: 1310:				for (int count = 0; count <= *piReadCount - size; count++) {
    #####: 1311:					if ((count % 50 == 0) && (count > 0))
        -: 1312:						fprintf(pfOut, "\n");
    #####: 1313:
    #####: 1314:					getsubstring(pchSequence, pchPattern, count,
    #####: 1315:							count + size - 1);
        -: 1316:					pchPattern[size] = '\0';
        -: 1317:					patternnumber = 0;
    #####: 1318:
    #####: 1319:					if (issegmentvalid(pchPattern) == 1) {
    #####: 1320:						getpatternmatrixindex(pchPattern, right, left);
        -: 1321:
    #####: 1322:						if (left >= matrixsize[right]) {
    #####: 1323:							getreversecomplement(pchPattern, pchReverse);
        -: 1324:							strcpy(pchPattern, pchReverse);
    #####: 1325:							getpatternmatrixindex(pchPattern, right, left);
    #####: 1326:						}
    #####: 1327:
    #####: 1328:						if (PatternMatrix[right][left])
        -: 1329:							patternnumber = 1;
        -: 1330:					}
    #####: 1331:
    #####: 1332:					//output the p cloud annotation file;
        -: 1333:					fprintf(pfOut, "%d ", patternnumber);
        -: 1334:
        -: 1335:					//get the annotated repeat region
    #####: 1336:					icount++;
        -: 1337:
        -: 1338:					if (icount <= windowsize) {
    #####: 1339:						occurrence.push_back(patternnumber);
        -: 1340:
    #####: 1341:						if (icount == windowsize) {
    #####: 1342:							if (isrepeatregion(occurrence, percent)) {
        -: 1343:								iStart = icount - windowsize + 1;
    #####: 1344:								iFormerStart = iStart;
    #####: 1345:								iEnd = 0;
    #####: 1346:							}
    #####: 1347:						}
    #####: 1348:					} else {
        -: 1349:						occurrence.erase(occurrence.begin());
        -: 1350:						occurrence.push_back(patternnumber);
        -: 1351:
    #####: 1352:						if (isrepeatregion(occurrence, percent)) {
    #####: 1353:							if (iStart == 0) {
        -: 1354:								iStart = icount - windowsize + 1;
    #####: 1355:
    #####: 1356:								if (iStart > iFormerEnd + 1) {
    #####: 1357:									if ((iFormerEnd != 0)
        -: 1358:											&& (iFormerStart != 0)) {
    #####: 1359:										fprintf(pfRegion, "%lld %lld\n",
    #####: 1360:												iFormerStart, iFormerEnd);
        -: 1361:										totalsize += iFormerEnd - iFormerStart
        -: 1362:												+ 1;
    #####: 1363:									}
        -: 1364:
    #####: 1365:									iFormerStart = iStart;
        -: 1366:								}
        -: 1367:
    #####: 1368:								iEnd = 0;
        -: 1369:							}
        -: 1370:						} else {
    #####: 1371:							if ((iStart != 0) && (iEnd == 0)) {
        -: 1372:								int i = windowsize - 1;
        -: 1373:
    #####: 1374:								while (occurrence[i] == 0)
    #####: 1375:									i--;
        -: 1376:
    #####: 1377:								iEnd = icount + size - 2 - (windowsize - 1 - i);
    #####: 1378:								iFormerEnd = iEnd;
        -: 1379:								iStart = 0;
    #####: 1380:							}
    #####: 1381:						}
    #####: 1382:					}
        -: 1383:				}
        -: 1384:			}
        -: 1385:			iOffset += m_nChunksize - size + 1;
        -: 1386:		} while ((iOffset < m_nGenomesize - size + 1) && (iRead == 2));
        -: 1387:
    #####: 1388:		fclose(pfGenome);
        -: 1389:	}
        -: 1390:
    #####: 1391:	fprintf(pfRegion, "%lld %lld\n", iFormerStart, iFormerEnd);
        -: 1392:
        -: 1393:	totalsize += iFormerEnd - iFormerStart + 1;
    #####: 1394:
        -: 1395:	fprintf(pfRegion, "%lld", totalsize);
    #####: 1396:	fflush(pfRegion);
        -: 1397:	fclose(pfRegion);
    #####: 1398:	fclose(pfOut);
    #####: 1399:	free(pchPattern);
    #####: 1400:	free(pchSequence);
    #####: 1401:	free(piReadCount);
    #####: 1402:	free(pchReverse);
    #####: 1403:
    #####: 1404:	return (1);
    #####: 1405:}
        -: 1406:
    #####: 1407://for 16mers, build the bool patternmatrix to ascertain which oligo is in the P clouds
        -: 1408://STP: Modified to annotate the positions of the clouds in repeat regions
        -: 1409:static int readclouds1(const char* pchMainCloudassign,
        -: 1410:		const char* pchAccCloudassign, bitvector& PatternVector,
        -: 1411:		vector<int>& CloudIdVector, const int& size) {
    #####: 1412:	FILE *pfMainCloudassign;
        -: 1413:	FILE *pfAccCloudassign;
        -: 1414:	char *pchLine;
        -: 1415:	char *pchTemp;
        -: 1416:	char* pchReverse;
        -: 1417:	unsigned long index;
        -: 1418:
        -: 1419:	if ((pfMainCloudassign = fopen(pchMainCloudassign, "r")) == NULL) {
        -: 1420:		printf("Can not find the cloud assign file: %s.\n", pchMainCloudassign);
        -: 1421:		return (0);
    #####: 1422:	} else {
    #####: 1423:		pchLine = (char *) malloc(sizeof(char) * MAXLINECHAR);
    #####: 1424:		pchTemp = (char*) malloc(sizeof(char) * (size + 1));
        -: 1425:		pchReverse = (char*) malloc(sizeof(char) * (size + 1));
    #####: 1426:
    #####: 1427:		while (!feof(pfMainCloudassign)) {
    #####: 1428:			if (fgets(pchLine, MAXLINECHAR, pfMainCloudassign) != NULL) {
        -: 1429:				strncpy(pchTemp, pchLine, size);
    #####: 1430:				*(pchTemp + size) = '\0';
    #####: 1431:
    #####: 1432:				patterntoindex(pchTemp, index, size);
    #####: 1433:
        -: 1434:				cout << "Found kmer " << pchTemp << " with index " << index
    #####: 1435:						<< endl;
        -: 1436:
    #####: 1437:				PatternVector[index] = true;
    #####: 1438:				CloudIdVector[index] = getnumber(pchLine);
        -: 1439:
    #####: 1440:				getreversecomplement(pchTemp, pchReverse);
    #####: 1441:				patterntoindex(pchReverse, index, size);
        -: 1442:
    #####: 1443:				cout << "Found kmer " << pchTemp << " with index " << index
    #####: 1444:						<< endl;
        -: 1445:
    #####: 1446:				PatternVector[index] = true;
    #####: 1447:				CloudIdVector[index] = getnumber(pchLine);
        -: 1448:			}
    #####: 1449:		}
    #####: 1450:
        -: 1451:		free(pchLine);
        -: 1452:		free(pchTemp);
        -: 1453:		free(pchReverse);
    #####: 1454:		fclose(pfMainCloudassign);
    #####: 1455:	}
    #####: 1456:
    #####: 1457:	if ((pfAccCloudassign = fopen(pchAccCloudassign, "r")) == NULL) {
        -: 1458:		printf("Can not find the cloud assign file: %s.\n", pchAccCloudassign);
        -: 1459:		return (0);
    #####: 1460:	} else {
    #####: 1461:		pchLine = (char *) malloc(sizeof(char) * MAXLINECHAR);
    #####: 1462:		pchTemp = (char*) malloc(sizeof(char) * (size + 1));
        -: 1463:		pchReverse = (char*) malloc(sizeof(char) * (size + 1));
    #####: 1464:
    #####: 1465:		while (!feof(pfAccCloudassign)) {
    #####: 1466:			if (fgets(pchLine, MAXLINECHAR, pfAccCloudassign) != NULL) {
        -: 1467:				strncpy(pchTemp, pchLine, size);
    #####: 1468:				*(pchTemp + size) = '\0';
    #####: 1469:
    #####: 1470:				patterntoindex(pchTemp, index, size);
    #####: 1471:				PatternVector[index] = true;
        -: 1472:
    #####: 1473:				//STP: Added for printing the positions of the clouds
    #####: 1474:				// in a repeat region
        -: 1475:				CloudIdVector[index] = getnumber(pchLine);
        -: 1476:				cout << "Found kmer " << pchTemp << " with index " << index
        -: 1477:						<< endl;
    #####: 1478:
    #####: 1479:				getreversecomplement(pchTemp, pchReverse);
    #####: 1480:				patterntoindex(pchReverse, index, size);
        -: 1481:
    #####: 1482:				PatternVector[index] = true;
    #####: 1483:
        -: 1484:				//STP: Added for printing the positions of the clouds
    #####: 1485:				// in a repeat region
        -: 1486:				CloudIdVector[index] = getnumber(pchLine);
        -: 1487:				cout << "Found kmer " << pchTemp << " with index " << index
        -: 1488:						<< endl;
    #####: 1489:			}
    #####: 1490:		}
    #####: 1491:
        -: 1492:		free(pchLine);
        -: 1493:		free(pchTemp);
        -: 1494:		free(pchReverse);
    #####: 1495:		fclose(pfAccCloudassign);
    #####: 1496:	}
    #####: 1497:
    #####: 1498:	return (1);
        -: 1499:}
        -: 1500:
    #####: 1501://for NON 16mers, annotate the genome based upon whether it is in the p clouds, and get the repeat regions
        -: 1502://but no p cloud pattern included in that annotation.
        -: 1503:static int GenomeScanAndIdentify1(const char* pchGenome, const char* pchOutfile,
        -: 1504:		const char* pchRegionfile, const bitvector& PatternVector,
        -: 1505:		const vector<int>& CloudIdVector, const int& kmer_size,
    #####: 1506:		const int& windowsize, const int& percent, const int& m_nChunksize,
        -: 1507:		const unsigned int& m_nGenomesize) {
        -: 1508:
        -: 1509:	cout << "Scanning genome for clouds..." << endl;
        -: 1510:	FILE *pfGenome;
        -: 1511:
    #####: 1512:	int *actual_chunk_size = (int*) malloc(sizeof(int));
        -: 1513:	char *chunk = (char*) malloc(sizeof(char) * m_nChunksize);
        -: 1514:	char *kmer_sequence = (char *) malloc(sizeof(char) * (kmer_size + 1));
    #####: 1515:	char *pchReverse = (char *) malloc(sizeof(char) * (kmer_size + 1));
    #####: 1516:
    #####: 1517:	long long chunk_start = 0;
    #####: 1518:	int iRead;
        -: 1519:
    #####: 1520:	FILE *pfOut = fopen(pchOutfile, "wb");
        -: 1521:
        -: 1522:	int patternnumber = 0;
    #####: 1523:	int cloud_id = 0;
        -: 1524:	unsigned long index = 0;
    #####: 1525:
    #####: 1526:	FILE *pfRegion = fopen(pchRegionfile, "wb");
    #####: 1527:
        -: 1528:	vector<int> occurrence(windowsize, 0);
    #####: 1529:
        -: 1530:	//STP: Added for annotating which clouds are in which repeat regions
    #####: 1531:	// Since queue has no 'erase' function, I'll use a deque which is the
        -: 1532:	// implementation anyway
        -: 1533:	deque<int> cloud_ids_in_region;
        -: 1534:
        -: 1535:	long long genome_position = 0;
    #####: 1536:	long long start = 0, end = 0;
        -: 1537:	long long former_start = 0;
    #####: 1538:	long long former_end = -1; // This must be initialized to < 0 in case the
    #####: 1539:								// first window is repetitive
    #####: 1540:	long long totalsize = 0;
    #####: 1541:
        -: 1542:	bool previous_window_was_repetitive = false;
    #####: 1543:	bool have_annotated_first_region = false;
        -: 1544:
    #####: 1545:	//STP: Added to print a header
    #####: 1546:	if (print_clouds_in_regions) {
        -: 1547:		fputs("Start\tEnd\tClouds\n", pfRegion);
        -: 1548:	}
    #####: 1549:	else {
    #####: 1550:		fputs("Start\tEnd\n", pfRegion);
        -: 1551:	}
        -: 1552:
    #####: 1553:	if ((pfGenome = fopen(pchGenome, "r")) == NULL) {
        -: 1554:		printf("Can not find the genome file: %s.\n", pchGenome);
        -: 1555:		return (0);
    #####: 1556:	} else {
    #####: 1557:		do {
    #####: 1558:			if (NULL == chunk) {
        -: 1559:				printf("The system can not allocate the memory!\n");
    #####: 1560:				free(kmer_sequence);
    #####: 1561:				free(pchReverse);
    #####: 1562:				free(actual_chunk_size);
    #####: 1563:				return (0);
    #####: 1564:			}
    #####: 1565:
    #####: 1566:			/* Does this handle the stretch of sequence at the junction
        -: 1567:			 between reads? Those need to be handled specially.
        -: 1568:			 They are handled specially below when the new iOffset is
        -: 1569:			 calculated. */
        -: 1570:			// STP: all ends should be exclusive -- double check
        -: 1571:			int chunk_end = chunk_start + m_nChunksize - 1;
        -: 1572:			if (chunk_end <= m_nGenomesize)
        -: 1573:				iRead = readfromfile(pfGenome, chunk, chunk_start, m_nChunksize,
    #####: 1574:						actual_chunk_size);
    #####: 1575:			else
        -: 1576:				iRead = readfromfile(pfGenome, chunk, chunk_start,
    #####: 1577:						m_nGenomesize - chunk_start, actual_chunk_size);
        -: 1578:
        -: 1579:			if (iRead == 0) {
    #####: 1580:				free(kmer_sequence);
        -: 1581:				free(chunk);
    #####: 1582:				free(pchReverse);
    #####: 1583:				free(actual_chunk_size);
    #####: 1584:				return (0);
    #####: 1585:			} else {
    #####: 1586:				//STP: Read has succeeded
    #####: 1587:				for (int site = 0; site <= *actual_chunk_size - kmer_size;
        -: 1588:						site++, genome_position++) {
        -: 1589:
    #####: 1590:					if ((site % 80 == 0) && (site != 0))
        -: 1591:						fprintf(pfOut, "\n");
        -: 1592:
    #####: 1593:					//STP: We don't need to copy the sequence here.
    #####: 1594:					// We could simply have a pointer to the chunk
        -: 1595:					getsubstring(chunk, kmer_sequence, site,
        -: 1596:							site + kmer_size - 1);
        -: 1597:
        -: 1598:					kmer_sequence[kmer_size] = '\0';
    #####: 1599:
        -: 1600:					patternnumber = 0;
    #####: 1601:					cloud_id = 0;
        -: 1602:
    #####: 1603:					if (issegmentvalid(kmer_sequence)) {
    #####: 1604:						patterntoindex(kmer_sequence, index, kmer_size);
        -: 1605:
    #####: 1606:						if (PatternVector[index]) {
    #####: 1607:							patternnumber = 1;
        -: 1608:
    #####: 1609:							cloud_id = CloudIdVector[index];
    #####: 1610:						}
        -: 1611:					}
    #####: 1612:
        -: 1613:					//output the p cloud annotation file;
        -: 1614:					fprintf(pfOut, "%d", patternnumber);
        -: 1615:
        -: 1616:					occurrence.erase(occurrence.begin());
    #####: 1617:					occurrence.push_back(patternnumber);
        -: 1618:
    #####: 1619:					cloud_ids_in_region.push_back(cloud_id);
    #####: 1620:
        -: 1621:					if (genome_position < (windowsize - 1)) {
    #####: 1622:						// for example, when genome_position is 9, we have
        -: 1623:						// looked at 10 kmers and filled a window of 10
    #####: 1624:						continue;
        -: 1625:						// Don't even consider if it is repetitive or not
        -: 1626:					}
    #####: 1627:
        -: 1628:					if (isrepeatregion(occurrence, percent)) {
        -: 1629:						if (not previous_window_was_repetitive) {
        -: 1630:							if (print_legacy_regions) {
    #####: 1631:								start = genome_position - (windowsize - 1) + 1;
    #####: 1632:							}
    #####: 1633:							else {
    #####: 1634:								start = genome_position - (windowsize - 1);
        -: 1635:							}
        -: 1636:
    #####: 1637:							if (start > former_end) {
        -: 1638:								// If the next repeat starts past the end
        -: 1639:								// of the former repeat
    #####: 1640:								// If not, merge.
        -: 1641:								// I'm not sure this if statement works with
        -: 1642:								// the legacy regions.
        -: 1643:
        -: 1644:								if (have_annotated_first_region) {
        -: 1645:									// Since we print the previous region,
        -: 1646:									// we need to have seen the first region
    #####: 1647:									// before we print
        -: 1648:									fprintf(pfRegion, "%lld\t%lld\t",
        -: 1649:											former_start, former_end);
        -: 1650:
        -: 1651:									if (print_clouds_in_regions) {
    #####: 1652:										int number_of_clouds_to_print = former_end
        -: 1653:												- kmer_size - former_start + 1;
    #####: 1654:
        -: 1655:										for (int cloud = 0;
    #####: 1656:												cloud < number_of_clouds_to_print;
        -: 1657:												cloud++) {
    #####: 1658:											fprintf(pfRegion, "%i ",
        -: 1659:													cloud_ids_in_region.front());
        -: 1660:											cloud_ids_in_region.pop_front();
        -: 1661:										}
    #####: 1662:									}
    #####: 1663:									fputs("\n", pfRegion);
        -: 1664:
        -: 1665:									// Erase all clouds up to a window size before the end
    #####: 1666:									cloud_ids_in_region.erase(
        -: 1667:											cloud_ids_in_region.begin(),
        -: 1668:											cloud_ids_in_region.end()
        -: 1669:													- windowsize);
        -: 1670:								}
        -: 1671:								else {
    #####: 1672:									have_annotated_first_region = true;
        -: 1673:								}
        -: 1674:
    #####: 1675:								former_start = start;
        -: 1676:							}
        -: 1677:						}
    #####: 1678:						previous_window_was_repetitive = true;
        -: 1679:					} else {
        -: 1680:						// Current window is not repetitive
    #####: 1681:						if (previous_window_was_repetitive) {
        -: 1682:							if (print_legacy_regions) {
        -: 1683:								// find the position of the  last cloud in the
    #####: 1684:								// previous repeat region
    #####: 1685:								// then add kmer_size to that
        -: 1686:
        -: 1687:								int i = windowsize - 1;
        -: 1688:
        -: 1689:								while (occurrence[i] == 0)
    #####: 1690:									i--;
        -: 1691:								// The legacy end is not exclusive
    #####: 1692:								former_end = genome_position + kmer_size - 1 - (windowsize - 1 - i);
    #####: 1693:							}
        -: 1694:							else {
    #####: 1695:								/*
        -: 1696:								 * The new way to calculate the former end is
        -: 1697:								 * more true to the method published in the
        -: 1698:								 * pclouds paper by wanjun.
        -: 1699:								 */
        -: 1700:								former_end = genome_position - 1 + kmer_size; // ends are exclusive
        -: 1701:							}
        -: 1702:						} else {
    #####: 1703:							if (not have_annotated_first_region) {
        -: 1704:								cloud_ids_in_region.pop_front();
        -: 1705:							}
    #####: 1706:						}
    #####: 1707:						previous_window_was_repetitive = false;
        -: 1708:					}
        -: 1709:				}
    #####: 1710:			}
        -: 1711:			// Subtract size in order to handle the break between chunks
        -: 1712:			// properly
        -: 1713:			chunk_start += m_nChunksize - kmer_size + 1;
        -: 1714:		} while ((chunk_start < m_nGenomesize - kmer_size + 1) && (iRead == 2));
        -: 1715:
    #####: 1716:		fclose(pfGenome);
        -: 1717:	}
        -: 1718:
    #####: 1719:	// If the last window was repetitive, update the former end
        -: 1720:	// This essentially makes the former end to be the genome size
        -: 1721:	if (previous_window_was_repetitive) {
        -: 1722:		if (print_legacy_regions) {
        -: 1723:			// What should happen here? '
    #####: 1724:			// The old Pclouds did not annotate the final region correctly.
    #####: 1725:			// Should I fix that here?
        -: 1726:			// For now, I have fixed it...
        -: 1727:
        -: 1728:			// find the position of the  last cloud in the
        -: 1729:			// previous repeat region
        -: 1730:			// then add kmer_size to that
        -: 1731:
        -: 1732:			int i = windowsize - 1;
        -: 1733:
        -: 1734:			while (occurrence[i] == 0)
    #####: 1735:				i--;
        -: 1736:			// The legacy end is not exclusive
    #####: 1737:			former_end = genome_position + kmer_size - 1 - (windowsize - 1 - i);
    #####: 1738:		}
        -: 1739:		else {
    #####: 1740:			/*
        -: 1741:			 * The new way to calculate the former end is
        -: 1742:			 * more true to the method published in the
        -: 1743:			 * pclouds paper by wanjun.
        -: 1744:			 */
        -: 1745:			former_end = genome_position - 1 + kmer_size; // ends are exclusive
        -: 1746:		}
        -: 1747:	}
    #####: 1748:
        -: 1749:	if (have_annotated_first_region) {
        -: 1750:		fprintf(pfRegion, "%lld\t%lld\t", former_start, former_end);
        -: 1751:		if (print_clouds_in_regions) {
    #####: 1752:			int number_of_clouds_to_print = former_end - kmer_size - former_start
    #####: 1753:					+ 1;
    #####: 1754:
        -: 1755:			for (int cloud = 0; cloud < number_of_clouds_to_print; cloud++) {
    #####: 1756:				fprintf(pfRegion, "%i ", cloud_ids_in_region.front());
        -: 1757:				cloud_ids_in_region.pop_front();
    #####: 1758:			}
    #####: 1759:		}
    #####: 1760:		fputs("\n", pfRegion);
        -: 1761:	}
        -: 1762:
    #####: 1763:	fflush(pfRegion);
        -: 1764:	fclose(pfRegion);
        -: 1765:	fclose(pfOut);
    #####: 1766:	free(kmer_sequence);
    #####: 1767:	free(chunk);
    #####: 1768:	free(actual_chunk_size);
    #####: 1769:	free(pchReverse);
    #####: 1770:
    #####: 1771:	return (1);
    #####: 1772:}
        -: 1773:
    #####: 1774:int pcloudsdissection(const char* pchControlfile) {
        -: 1775:	int oligo_size, windowsize, percent, m_nGetclouds, m_nDissection;
        -: 1776:
        2: 1777:	int m_nStep1, m_nStep2, m_nStep3, core_threshold, outer_threshold,
        -: 1778:			m_nChunksize;
        -: 1779:	unsigned int m_nGenomesize;
        -: 1780:
        -: 1781:	char pchrepeatfile[MAXFILENAMELENGTH], pchMainClouds[MAXFILENAMELENGTH],
        -: 1782:			pchMainAssign[MAXFILENAMELENGTH], pchAccAssign[MAXFILENAMELENGTH];
        -: 1783:	char pchGenome[MAXFILENAMELENGTH], pchAnnotationfile[MAXFILENAMELENGTH],
        -: 1784:			pchRegionfile[MAXFILENAMELENGTH];
        -: 1785:
        -: 1786:	int number_of_core_kmers, number_of_outer_kmers;
        -: 1787:
        -: 1788:	// read the control file the get the parameters of the program
        -: 1789:	if (!ReadPcloudsControlfile(pchControlfile, oligo_size, outer_threshold,
        -: 1790:			core_threshold, m_nStep1, m_nStep2, m_nStep3, m_nChunksize,
        -: 1791:			m_nGenomesize, windowsize, percent, m_nGetclouds, m_nDissection,
        2: 1792:			pchrepeatfile, pchGenome, pchMainClouds, pchMainAssign,
        -: 1793:			pchAccAssign, pchAnnotationfile, pchRegionfile)) {
        -: 1794:		cerr << "Open Control file error." << endl;
        -: 1795:		return (-1);
        2: 1796:	}
    #####: 1797:
    #####: 1798:	if (m_nGetclouds) {
        -: 1799:		if (readrepeatnumber(pchrepeatfile, number_of_core_kmers,
        -: 1800:				number_of_outer_kmers, oligo_size, m_nStep1, core_threshold,
        2: 1801:				outer_threshold)) {
        2: 1802:
        -: 1803:			cloud_type3* main_oligos = new cloud_type3[number_of_core_kmers];
        2: 1804:
        -: 1805:			readmainoligos(pchrepeatfile, main_oligos, number_of_core_kmers,
        2: 1806:					oligo_size, m_nStep1, core_threshold);
        -: 1807:
        -: 1808:			cout << "number of core kmers " << number_of_core_kmers << endl;
        2: 1809:
        -: 1810:			buildmainpcloud(main_oligos, pchMainClouds, number_of_core_kmers,
        2: 1811:					oligo_size, core_threshold);
        -: 1812:			outputmainclouds(main_oligos, pchMainAssign, number_of_core_kmers,
        -: 1813:					oligo_size);
        2: 1814:
        -: 1815:			delete[] (main_oligos);
        2: 1816:
        -: 1817:			cloud_type2* pMainCloudsA = (cloud_type2*) malloc(
        2: 1818:					sizeof(cloud_type2) * MAXMAINMER);
        -: 1819:			cloud_type2* pMainCloudsB = (cloud_type2*) malloc(
        -: 1820:					sizeof(cloud_type2) * MAXMAINMER);
        2: 1821:			cloud_type2* pMainCloudsC = (cloud_type2*) malloc(
        -: 1822:					sizeof(cloud_type2) * MAXMAINMER);
        2: 1823:			int numberA, numberB, numberC;
        -: 1824:
        2: 1825:			readmainclouds(pchMainAssign, pMainCloudsA, numberA, pMainCloudsB,
        -: 1826:					numberB, pMainCloudsC, numberC, oligo_size, m_nStep1,
        -: 1827:					m_nStep2, m_nStep3);
        -: 1828:			buildaccessarypcloud(pchrepeatfile, pchAccAssign, pMainCloudsA,
        -: 1829:					numberA, pMainCloudsB, numberB, pMainCloudsC, numberC,
        2: 1830:					number_of_outer_kmers, oligo_size, m_nStep1, core_threshold,
        -: 1831:					outer_threshold);
        -: 1832:
        -: 1833:			free(pMainCloudsA);
        2: 1834:			free(pMainCloudsB);
        -: 1835:			free(pMainCloudsC);
        2: 1836:
        2: 1837:		} else {
        2: 1838:			cerr << "Open word count file error." << endl;
        -: 1839:			return (-1);
        -: 1840:		}
    #####: 1841:	}
    #####: 1842:
        -: 1843:	if (m_nDissection) {
        -: 1844:		bitvector PatternVector((unsigned long) pow(4, oligo_size), false);
        -: 1845:		vector<int> CloudIdVector((unsigned long) pow(4, oligo_size), 0);
        2: 1846:
    #####: 1847:		readclouds1(pchMainAssign, pchAccAssign, PatternVector, CloudIdVector,
    #####: 1848:				oligo_size);
        -: 1849:
        -: 1850:		if (not GenomeScanAndIdentify1(pchGenome, pchAnnotationfile,
    #####: 1851:				pchRegionfile, PatternVector, CloudIdVector, oligo_size,
        -: 1852:				windowsize, percent, m_nChunksize, m_nGenomesize)) {
    #####: 1853:			cerr << "Genome Annotation and Repeat Region Identification Error."
        -: 1854:					<< endl;
    #####: 1855:			PatternVector.clear();
    #####: 1856:			return (-1);
    #####: 1857:		}
    #####: 1858:
    #####: 1859:		PatternVector.clear();
        -: 1860:	}
        -: 1861:
    #####: 1862:	return (1);
        -: 1863:}
        -: 1864:/*EOF*/
        2: 1865:/*EOF*/
        6: 1866:/*EOF*/
