//for 16mers, annotate the genome based upon whether it is in the p clouds, and get the repeat regions
//but no p cloud pattern included in that annotation.
static int GenomeScanAndIdentify1(const char* pchGenome, const char* pchOutfile, const char* pchRegionfile, const bitvector& PatternVector, const int& size, const int& windowsize, const int& percent, const int& m_nChunksize, const unsigned int& m_nGenomesize)
{
	FILE *pfGenome;

	char *pchPattern;
	int *piReadCount = (int*) malloc(sizeof(int));
        char *pchSequence = (char*) malloc(sizeof(char) * m_nChunksize);
        pchPattern = (char *) malloc(sizeof(char) * (size+1));
        char *pchReverse = (char *) malloc(sizeof(char) * (size+1));
        
        long long iOffset = 0;
	int iRead;

	FILE *pfOut;
	
	pfOut = fopen(pchOutfile, "wb");

	int patternnumber;
	unsigned long index;

	FILE *pfRegion;

	vector<int> occurrence;

	long long icount = 0;
	long long iStart = 0, iEnd = 0;
	long long iFormerStart = 0, iFormerEnd = 0;
	long long totalsize = 0;

	pfRegion = fopen(pchRegionfile, "wb");

	if( ( pfGenome = fopen( pchGenome, "r" )) == NULL )
	{
		printf("Can not find the genome file: %s.\n", pchGenome);
		return(0);
	}
	else 
	{
		do 
		{	
			if ( NULL == pchSequence ) 
			{
				printf("The system can not allocate the memory!\n");
				free(pchPattern);
				free(pchReverse);
				free(piReadCount);
                                return(0);
			}
		
			if (iOffset + m_nChunksize -1 <= m_nGenomesize)
				iRead = readfromfile(pfGenome, pchSequence, iOffset, m_nChunksize, piReadCount);
			else 
				iRead = readfromfile(pfGenome, pchSequence, iOffset, m_nGenomesize - iOffset, piReadCount);

			if ( iRead == 0 ) 
			{
				free(pchPattern);
				free(pchSequence);
				free(pchReverse);
				free(piReadCount);
				return(0);
			}
			else
			{
				for (int count =0; count <= *piReadCount - size; count ++)
				{
					if ( (count % 50 == 0) && (count>0))
						fprintf(pfOut, "\n");

					getsubstring(pchSequence, pchPattern, count, count + size - 1);
					pchPattern[size] = '\0';
					patternnumber = 0;

					if (issegmentvalid(pchPattern)==1)
					{
						patterntoindex(pchPattern, index, size);

						if (PatternVector[index])
							patternnumber = 1;
					}

					//output the p cloud annotation file;
					fprintf(pfOut, "%d ", patternnumber);

					//get the annotated repeat region
					icount++;

					if (icount <= windowsize)
					{
						occurrence.push_back(patternnumber);

						if (icount == windowsize)
						{
							if (isrepeatregion(occurrence, percent))
							{
								iStart = icount - windowsize +1;
								iFormerStart = iStart;
								iEnd = 0;
							}
						}
					}
					else
					{
						occurrence.erase(occurrence.begin());
						occurrence.push_back(patternnumber);

						if (isrepeatregion(occurrence, percent))
						{
							if (iStart == 0)
							{
								iStart = icount - windowsize+1;

								if (iStart > iFormerEnd + 1)
								{
									if ((iFormerEnd != 0) && (iFormerStart !=0))
									{
										fprintf(pfRegion, "%lld %lld\n", iFormerStart, iFormerEnd);
										totalsize += iFormerEnd - iFormerStart + 1;
									}

									iFormerStart = iStart;
								}

								iEnd = 0;
							}
						}
						else
						{
							if ((iStart != 0) && (iEnd == 0))
							{
								int i = windowsize -1;

								while (occurrence[i] == 0)
									i--;
		
								iEnd = icount + size - 2 - (windowsize-1 - i);
								iFormerEnd = iEnd;
								iStart = 0;
							}
						}
					}
				}
			}
			iOffset += m_nChunksize - size +1;
		}
		while ((iOffset < m_nGenomesize - size +1) && (iRead == 2)); 

		fclose( pfGenome);
	}

	fprintf(pfRegion, "%lld %lld\n", iFormerStart, iFormerEnd);

	totalsize += iFormerEnd - iFormerStart + 1;

	fprintf(pfRegion, "%lld", totalsize);

	fflush(pfRegion);
	fclose(pfRegion);
	fclose(pfOut);
	free(pchPattern);
	free(pchSequence);
	free(piReadCount);
        free(pchReverse);

	return(1);
}
