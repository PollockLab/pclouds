void ReadRegionsFile(string regions_file,
		vector<pair<long long int, long long int> >& regions) {

	ifstream regions_in(regions_file.c_str());

	if (not regions_in.good()) {
		cerr << "Could not read regions file" << endl;
		exit(-1);
	}

	while (regions_in.good()) {
		pair<long long int, long long int> region;
		regions_in >> region.first;
		regions_in >> region.second;

		//STP: Skip blank lines (the last line is often blank)
		if (region.first == 0 and region.second == 0) {
			continue;
		}

		if (region.first >= region.second) {
			cerr << "Found a region with beginning equal to or after the end. "
					<< "Start: " << region.first << " End: " << region.second
					<< endl;
			exit(-1);
		}
		regions.push_back(region);
	}
}

void getRegionsFile( string fname, vector< pair< long long int, long long int > >& regions ) {
    vector<string> tok;
    pair< long long int, long long int > tempRegion;

    ifstream in;
    
    in.open( fname.c_str(), ios::in );
    
    if (!in.is_open()) {
        cerr << "Could not open file" << endl;
        exit(-1);
    }

    // Temp strings
    string header;
    string seq;

    // Fix the number of columns for speed
    tok.resize( 2 );
    
    int openSeq = 0;
    
    stringstream convert;
    long long int first, second;
    
    // Dump the file to buffer, line by line
    string line;
    while (in.good()) {
    
        getline( in, line );
        chomp( line );

        tokenize( line, '\t', tok, 2 );

        convert.clear();
        convert << tok[0];
        convert >> first;

        second = -1;
        convert.clear();
        convert << tok[1];
        convert >> second;

        if ( ( second > first ) && ( second != -1 ) ) {
            tempRegion = make_pair( first, second );
            regions.push_back( tempRegion );
        }        

    } // while
    
    in.close();
   
}